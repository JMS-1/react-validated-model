{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@jms-1/react-validated-model/webpack/universalModuleDefinition","webpack://@jms-1/react-validated-model/external umd \"fastest-validator\"","webpack://@jms-1/react-validated-model/external umd {\"amd\":\"react\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"root\":\"React\"}","webpack://@jms-1/react-validated-model/webpack/bootstrap","webpack://@jms-1/react-validated-model/webpack/runtime/compat get default export","webpack://@jms-1/react-validated-model/webpack/runtime/define property getters","webpack://@jms-1/react-validated-model/webpack/runtime/hasOwnProperty shorthand","webpack://@jms-1/react-validated-model/webpack/runtime/make namespace object","webpack://@jms-1/react-validated-model/./src/index.tsx"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"fastest-validator\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"fastest-validator\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@jms-1/react-validated-model\"] = factory(require(\"fastest-validator\"), require(\"react\"));\n\telse\n\t\troot[\"@jms-1/react-validated-model\"] = factory(root[\"fastest-validator\"], root[\"React\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types, no-prototype-builtins */\n\nimport Validator, { ValidationError, ValidationSchema } from 'fastest-validator'\nimport * as React from 'react'\n\n/** Steuerschnittstelle für Modelldaten. */\nexport interface IModelControl {\n    /**\n     * Ermittelt Prüfergebnisse zu einem Feld.\n     *\n     * @param prop Das gewünscht Feld (e.g. name aber auch children[13].age)\n     * oder alle Prüfergebnisse zu den Modelldaten, wenn leer oder weggelassen.\n     */\n    findErrors(prop?: string): ValidationError[]\n\n    /**\n     * Meldet, ob die Modelldaten von den Daten von den Originaldaten\n     * abweichen. Dies umfasst auch eine strukturelle Prüfung, i.e. wenn\n     * die Eigenschaften in den Originaldaten nicht in kanonischer\n     * Reigenfolge angeordnet sind, können die Modelldaten trotz\n     * inhaltlicher Identität als verändert angezeigt werden.\n     */\n    isDirty(): boolean\n\n    /**\n     * Setzt die Modelldaten auf die Originaldaten zurück.\n     */\n    reset(): void\n}\n\n/** Eindeutige Kennung werden auf die einfachst mögliche Art erstellt. */\nlet counter = 0\n\n/**\n * Meldet verändertliche Modelldaten zu einem Objekt.\n *\n * @param original Die originalen Daten.\n * @param schema Optional die Prüfregeln für die Modelldaten.\n * @returns Ein Feld mit den veränderlichen Modelldaten und einem zusätzlichen Steuerobjekt.\n */\nexport function useModel<T extends object>(original: T, schema: ValidationSchema = {}): [T, IModelControl] {\n    /**\n     * Eine Veränderung an diesem Indikator führt dazu, dass die Modelldaten\n     * aus dem Original neu geladen werden.\n     */\n    const [resetId, setResetId] = React.useState(++counter)\n\n    /**\n     * Dieser Indikator wird immer dann verändert, wenn sich die Modelldaten\n     * verändert haben. Letztlich wird dadurch ein neuer Render-Zyklus\n     * ausgelöst.\n     */\n    const [refreshId, setRefreshId] = React.useState(++counter)\n\n    /**\n     * Die eindeutige Serialisierung des Originals. Sollte diese kein Objekt\n     * sein (wir verlassen uns hier erst einmal nur auf TypeScript, was ja\n     * sicher kein echter Schutz ist), kann in der Folge alles mögliche\n     * passieren.\n     *\n     * Es wird erwartet, dass sich das Orginal nur als Ganzes (Referenz)\n     * verändert. Innere Änderung werden nicht wahrgenommen.\n     */\n    const originalStr = React.useMemo(() => JSON.stringify(original || {}), [original])\n\n    /**\n     * Die Prüfregeln müssen im Allgemeinen nur ein einziges Mal erstellt\n     * werden, werden aber bei jeder Änderung angewendet, daher ist eine\n     * Vorübersetzung sinnvoll. Asynchrone Prüfungen werden nicht unterstützt\n     * und werden zu schwerem Fehlverhalten führen.\n     */\n    const validator = React.useMemo(() => new Validator().compile(schema), [schema])\n\n    /**\n     * Die Modelldaten sind erst einmal eine Kopie der Originaldaten, im\n     * Gegensatz dazu aber veränderlich.\n     *\n     * Der resetId Indikator kann durch Verändern dazu verwendet werden,\n     * die ursprünglichen Daten erneut zu laden.\n     *\n     * Sicherheitshalber erfolgt dies auch, wenn sich das Original\n     * verändert, aber aus den selben Daten wie das vorherige besteht.\n     * Ohne diesen Trigger würden sonst Veränderungen an den Originaldaten\n     * nicht zurück gesetzt.\n     */\n    const model = React.useMemo(\n        () => (!resetId || !original || true) && (JSON.parse(originalStr) as T),\n        [originalStr, original, resetId]\n    )\n\n    /**\n     * Verändert den Indikator für das Zurücksetzen der Modelldaten.\n     */\n    const reset = React.useCallback(() => setResetId(++counter), [])\n\n    /**\n     * Meldet durch die Veränderung des Indikators veränderte\n     * Modelldaten.\n     */\n    const refresh = React.useCallback(() => setRefreshId(++counter), [])\n\n    /**\n     * Erstellt für ein beliebiges Objekt einen Proxy - das\n     * gilt zum Beispiel auch für Felder (Array) oder\n     * Datumsobjekte (Date).\n     *\n     * Beim Zugriff auf die Eigenschaften des Objektes werden\n     * bei be Bedarf weitere Proxies erstellt. Solange keine\n     * Änderungen an den Daten vorgenommen werden, bleibt die\n     * Objektidentitär (===) dieser Proxies erhalten.\n     */\n    const createProxy = React.useCallback(\n        (obj: any): any => {\n            const getMap: Record<string | symbol, unknown> = {}\n\n            return new Proxy(obj, {\n                get(target, prop) {\n                    /**\n                     * Um keine unnötigen Render Zyklen auszulösen sollten\n                     * wir immer den selben Proxy melden.\n                     */\n                    if (getMap.hasOwnProperty(prop)) {\n                        return getMap[prop]\n                    }\n\n                    /**\n                     * Gibt es keinen Wert (undefined oder null) kann\n                     * dieser unverändert gemeldet werden.\n                     */\n                    const value: unknown = target[prop]\n\n                    if (value == null) {\n                        return value\n                    }\n\n                    switch (typeof value) {\n                        case 'object':\n                            /**\n                             * Wenn ein neuer Proxy erzeugt werden muss, so passiert dies\n                             * nur einmal um nicht unnötige Render Zyklen auszulösen.\n                             */\n                            return (getMap[prop] = createProxy(value))\n                        case 'function':\n                            /**\n                             * Methoden werden erst einmal nur sehr naiv umgesetzt.\n                             */\n                            return (...args: unknown[]) => {\n                                /**\n                                 * Zuerst merken wir uns den aktuellen Wert der Daten.\n                                 */\n                                const before = JSON.stringify(target)\n\n                                /**\n                                 * Dann wird die Methode blind aufgerufen - im Umgang\n                                 * mit call oder apply muss man dabei sehr vorsichtig\n                                 * sein.\n                                 */\n                                const result = value.call(target, ...args)\n\n                                /**\n                                 * Wurden Daten verändert (e.g. splice oder push auf\n                                 * ein Feld), dann wird der Änderungsindikator verändert.\n                                 * Ansonsten (e.g. slice oder map auf ein Feld) passiert\n                                 * einfach gar nichts.\n                                 */\n                                if (JSON.stringify(target) !== before) {\n                                    refresh()\n                                }\n\n                                /**\n                                 * Das Ergebnis der Methode muss natürlich auf jeden Fall\n                                 * als Resultat gemeldet werden.\n                                 */\n                                return result\n                            }\n                        default:\n                            /**\n                             * Skalare Werte werden direkt gemeldet. Ein Date Wert\n                             * gehört da natürlich nicht dazu.\n                             */\n                            return value\n                    }\n                },\n                set(target, prop, item) {\n                    /**\n                     * Beim Setzen von Eigenschaften wird auf die Referenz\n                     * geprüft - bei skalaren Werten natürlich direkt der\n                     * Wert.\n                     */\n                    if (target[prop] !== item) {\n                        /**\n                         * Wurde bereits ein Proxy erstellt, so ist dieser\n                         * nun natürlich nicht mehr gültig.\n                         */\n                        delete getMap[prop]\n\n                        /**\n                         * Der Wert wird überschrieben und eine Aktualisierung\n                         * über den Änderungsindikator angezeigt. Zur Sicherheit\n                         * wird immer eine JSON Kopie der neuen Daten verwendet.\n                         */\n                        target[prop] = item === undefined ? item : JSON.parse(JSON.stringify(item))\n\n                        refresh()\n                    }\n\n                    return true\n                },\n            })\n        },\n        [refresh]\n    )\n\n    /**\n     * Die Modelldaten werden in einem Proxy gekapselt zurückgeliefert,\n     * der aus Faulheit allerdings nur get und set überwacht. Für die\n     * meisten Anwendungsfälle wird das ausreichend sein.\n     *\n     * Im Allgemeinen wird ein neuer Proxy erstellt, sobald der\n     * Indikator für die Veränderung an den Modelldaten sich verändert\n     * hat. Dies löst dann im Allgemeinen einen Render Zyklus aus.\n     */\n    const proxy = React.useMemo(() => (!refreshId || true) && createProxy(model), [model, createProxy, refreshId])\n\n    /**\n     * Die Prüfung durch den fastest-validator erfolgt nur, wenn\n     * sie auch explizit abgefragt wird.\n     */\n    const errors = React.useCallback(\n        () => (!refreshId || true) && (validator(model) as ValidationError[] | true),\n        [model, validator, refreshId]\n    )\n\n    /**\n     * Die Prüfergebnisse werden über eine Hilfsmethode zur Verfügung\n     * gestellt, Die einen einfachen Zugriff auf die Prüfung einzelner\n     * Felder des Objektes erlaubt.\n     */\n    const findErrors = React.useCallback(\n        (prop: string) => {\n            /** Erst einal prüfen, ob überhaupt Fehler aufgetreten sind. */\n            const all = errors()\n\n            if (all === true) {\n                return []\n            }\n\n            /** Das gesamte Prüfergebnis melden - über alle Eigenschaften. */\n            if (!prop) {\n                return all\n            }\n\n            /** Das Prüfergebnis zu einer einzelnen Eigenschaft. */\n            const prefix1 = `${prop}.`\n            const prefix2 = `${prop}[`\n\n            return all.filter(\n                (e) => e.field && (e.field === prop || e.field.startsWith(prefix1) || e.field.startsWith(prefix2))\n            )\n        },\n        [errors]\n    )\n\n    /**\n     * Prüft auf Wunsch, ob sich irgendwas an den Eingangsdaten\n     * verändert hat.\n     */\n    const isDirty = React.useCallback(\n        () => (!refreshId || true) && JSON.stringify(model) !== originalStr,\n        [model, originalStr, refreshId]\n    )\n\n    /** Erstellt zusäzlich zu dem Proxy der Modelldaten ein Steuerobject. */\n    const control = React.useMemo<IModelControl>(() => ({ findErrors, isDirty, reset }), [reset, findErrors, isDirty])\n\n    return [proxy, control]\n}\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","counter","useModel","original","schema","resetId","setResetId","refreshId","setRefreshId","originalStr","JSON","stringify","validator","compile","model","parse","reset","refresh","createProxy","getMap","Proxy","target","args","before","result","set","item","proxy","errors","findErrors","all","prefix1","prefix2","filter","e","field","startsWith","isDirty"],"sourceRoot":""}